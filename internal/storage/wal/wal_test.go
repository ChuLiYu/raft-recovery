package wal

// ============================================================================
// WAL 測試檔案
// 職責：驗證 WAL 的正確性、並發安全性與錯誤處理
// ============================================================================

import (
	"encoding/json"
	"fmt"
	"os"
	"sync"
	"testing"
	"time"

	"github.com/ChuLiYu/raft-recovery/pkg/types"
	"github.com/stretchr/testify/assert"
)

// ============================================================================
// 基礎功能測試
// ============================================================================

// TestNewWAL 測試 WAL 建立
func TestNewWAL(t *testing.T) {
	tempFile := "test_wal.log"
	defer os.Remove(tempFile)

	wal, err := NewWAL(tempFile, true)
	assert.NoError(t, err)
	assert.NotNil(t, wal)
	assert.Equal(t, uint64(0), wal.seq)
}

// TestAppend 測試事件追加
func TestAppend(t *testing.T) {
	tempFile := "test_wal_append.log"
	defer os.Remove(tempFile)

	wal, err := NewWAL(tempFile, true)
	assert.NoError(t, err)

	// Append a single event
	event := Event{
		Type:      "ENQUEUE",
		JobID:     "job_1",
		Timestamp: time.Now().UnixMilli(),
	}
	err = wal.Append(event.Type, types.Job{ID: event.JobID}, true)
	assert.NoError(t, err)

	// Append multiple events
	events := []Event{
		{Type: "DISPATCH", JobID: "job_2", Timestamp: time.Now().UnixMilli()},
		{Type: "ACK", JobID: "job_3", Timestamp: time.Now().UnixMilli()},
	}
	for _, e := range events {
		err = wal.Append(e.Type, types.Job{ID: e.JobID}, true)
		assert.NoError(t, err)
	}

	// Close WAL to flush buffer
	err = wal.Close()
	assert.NoError(t, err)

	// Verify events in the file
	file, err := os.Open(tempFile)
	assert.NoError(t, err)
	defer file.Close()

	decoder := json.NewDecoder(file)
	for i, expected := range append([]Event{event}, events...) {
		var logged Event
		assert.NoError(t, decoder.Decode(&logged))
		assert.Equal(t, expected.Type, logged.Type)
		assert.Equal(t, expected.JobID, logged.JobID)
		assert.NotZero(t, logged.Checksum)
		assert.NotZero(t, logged.Timestamp)
		assert.Equal(t, uint64(i+1), logged.Seq)
	}
}

// TestReplay 測試事件重放
func TestReplay(t *testing.T) {
	tempFile := "test_wal_replay.log"
	defer os.Remove(tempFile)

	wal, err := NewWAL(tempFile, true)
	assert.NoError(t, err)

	// Append multiple events
	events := []Event{
		{Type: "ENQUEUE", JobID: "job_1", Timestamp: time.Now().UnixMilli()},
		{Type: "DISPATCH", JobID: "job_2", Timestamp: time.Now().UnixMilli()},
		{Type: "ACK", JobID: "job_3", Timestamp: time.Now().UnixMilli()},
	}
	for _, e := range events {
		err = wal.Append(e.Type, types.Job{ID: e.JobID}, true)
		assert.NoError(t, err)
	}

	// Close WAL to flush buffer
	err = wal.Close()
	assert.NoError(t, err)

	// Replay events
	replayedEvents := []Event{}
	handler := func(e Event) error {
		replayedEvents = append(replayedEvents, e)
		return nil
	}

	wal, err = NewWAL(tempFile, true)
	assert.NoError(t, err)
	err = wal.Replay(handler)
	assert.NoError(t, err)

	// Validate replayed events
	assert.Equal(t, len(events), len(replayedEvents))
	for i, expected := range events {
		assert.Equal(t, expected.Type, replayedEvents[i].Type)
		assert.Equal(t, expected.JobID, replayedEvents[i].JobID)
		// Seq is auto-generated by WAL, so we verify it's sequential
		assert.Equal(t, uint64(i+1), replayedEvents[i].Seq)
	}
}

// TestRotate 測試日誌旋轉
func TestRotate(t *testing.T) {
	tempFile := "test_wal.log"
	defer os.Remove(tempFile)

	wal, err := NewWAL(tempFile, true)
	assert.NoError(t, err)

	err = wal.Rotate()
	assert.NoError(t, err)

	_, err = os.Stat(tempFile)
	assert.NoError(t, err)
}

// TestCompressWALFile 測試 WAL 檔案壓缩
func TestCompressWALFile(t *testing.T) {
	srcFile := "test_wal.log"
	dstFile := "test_wal.log.gz"
	defer os.Remove(srcFile)
	defer os.Remove(dstFile)

	// Create a dummy WAL file
	file, err := os.Create(srcFile)
	assert.NoError(t, err)
	defer file.Close()

	_, err = file.WriteString("dummy data")
	assert.NoError(t, err)

	err = compressWALFile(srcFile, dstFile)
	assert.NoError(t, err)

	_, err = os.Stat(dstFile)
	assert.NoError(t, err)
}

// TestSplitWALFile 測試 WAL 檔案分割
func TestSplitWALFile(t *testing.T) {
	srcFile := "test_wal.log"
	defer os.Remove(srcFile)

	// Create a dummy WAL file
	file, err := os.Create(srcFile)
	assert.NoError(t, err)
	defer file.Close()

	events := []Event{
		{Seq: 1, Type: "TEST", JobID: "job1", Timestamp: 1234567890, Checksum: 12345},
		{Seq: 2, Type: "TEST", JobID: "job2", Timestamp: 1234567891, Checksum: 12346},
		{Seq: 3, Type: "TEST", JobID: "job3", Timestamp: 1234567892, Checksum: 12347},
	}
	encoder := json.NewEncoder(file)
	for _, event := range events {
		assert.NoError(t, encoder.Encode(event))
	}
	file.Close() // Close before splitting

	files, err := splitWALFile(srcFile, 60) // Each event is ~65 bytes, so this should split
	assert.NoError(t, err)
	assert.True(t, len(files) > 1, "Expected more than 1 file, got %d", len(files))

	for _, f := range files {
		defer os.Remove(f)
	}
}

// ============================================================================
// 錯誤處理測試
// ============================================================================

// TestChecksumValidation 測試校驗和驗證
func TestChecksumValidation(t *testing.T) {
	tempFile := "test_wal.log"
	defer os.Remove(tempFile)

	wal, err := NewWAL(tempFile, true)
	assert.NoError(t, err)

	event := Event{
		Seq:       1,
		Type:      "TEST_EVENT",
		JobID:     "job_123",
		Timestamp: time.Now().UnixMilli(),
	}
	err = wal.Append(event.Type, types.Job{ID: event.JobID}, true)
	assert.NoError(t, err)

	// Close to flush
	err = wal.Close()
	assert.NoError(t, err)

	// Read the event and modify its checksum
	file, err := os.OpenFile(tempFile, os.O_RDWR, 0644)
	assert.NoError(t, err)

	// Read the original event
	decoder := json.NewDecoder(file)
	var storedEvent Event
	err = decoder.Decode(&storedEvent)
	assert.NoError(t, err)

	// Modify checksum
	storedEvent.Checksum = storedEvent.Checksum + 1

	// Overwrite the file with corrupted event
	file.Close()
	file, err = os.OpenFile(tempFile, os.O_RDWR|os.O_TRUNC, 0644)
	assert.NoError(t, err)
	encoder := json.NewEncoder(file)
	err = encoder.Encode(storedEvent)
	assert.NoError(t, err)
	file.Close()

	// Replay 應回傳 ErrChecksumMismatch
	handler := func(e Event) error {
		return nil
	}
	wal, err = NewWAL(tempFile, true)
	assert.NoError(t, err)
	err = wal.Replay(handler)
	assert.Error(t, err)
	assert.Contains(t, err.Error(), "checksum mismatch")
}

// TestCorruptedWAL 測試損壞的 WAL 處理
func TestCorruptedWAL(t *testing.T) {
	tempFile := "test_wal.log"
	defer os.Remove(tempFile)

	// 建立包含無效 JSON 的 WAL 檔案
	file, err := os.Create(tempFile)
	assert.NoError(t, err)
	_, err = file.WriteString("{invalid_json}")
	assert.NoError(t, err)
	file.Close()

	// 嘗試 Replay
	wal, err := NewWAL(tempFile, true)
	assert.NoError(t, err)
	handler := func(e Event) error {
		return nil
	}
	err = wal.Replay(handler)
	assert.Error(t, err)
	assert.Contains(t, err.Error(), "invalid character")
}

// TestSyncFailure 測試 Sync 失敗處理
func TestSyncFailure(t *testing.T) {
	tempFile := "test_wal_sync_failure.log"
	defer os.Remove(tempFile)

	// Mock WAL with a file that fails on Sync
	mockFile := &MockFile{
		WriteFunc: func(p []byte) (n int, err error) {
			return len(p), nil
		},
		SyncFunc: func() error {
			return ErrSyncFailed
		},
	}

	wal := &WAL{
		file:          mockFile,
		seq:           0,
		buffer:        make([]Event, 0),
		bufferSize:    1, // Set to 1 to trigger immediate flush
		lastFlushTime: time.Now().Add(-2 * time.Second),
		flushInterval: 1 * time.Second,
	}
	wal.encoder = json.NewEncoder(mockFile)

	// Attempt to append an event - should trigger flush and fail on Sync
	event := Event{
		Type:      "ENQUEUE",
		JobID:     "job_1",
		Timestamp: time.Now().UnixMilli(),
	}
	err := wal.Append(event.Type, types.Job{ID: event.JobID}, true)
	assert.Error(t, err)
	assert.Equal(t, ErrSyncFailed, err)
}

// ============================================================================
// 並發安全測試
// ============================================================================

// TestConcurrentAppend 測試並發寫入
func TestConcurrentAppend(t *testing.T) {
	tempFile := "test_wal_concurrent_append.log"
	defer os.Remove(tempFile)

	wal, err := NewWAL(tempFile, true)
	assert.NoError(t, err)

	numGoroutines := 10
	eventsPerGoroutine := 100
	totalEvents := numGoroutines * eventsPerGoroutine

	// Use a WaitGroup to synchronize goroutines
	var wg sync.WaitGroup
	wg.Add(numGoroutines)

	for i := 0; i < numGoroutines; i++ {
		go func(gid int) {
			defer wg.Done()
			for j := 0; j < eventsPerGoroutine; j++ {
				event := Event{
					Type:      "ENQUEUE",
					JobID:     types.JobID(fmt.Sprintf("job_%d_%d", gid, j)),
					Timestamp: time.Now().UnixMilli(),
				}
				err := wal.Append(event.Type, types.Job{ID: event.JobID}, false)
				assert.NoError(t, err)
			}
		}(i)
	}

	wg.Wait()

	// Close WAL to flush all buffered events
	err = wal.Close()
	assert.NoError(t, err)

	// Validate the total number of events
	file, err := os.Open(tempFile)
	assert.NoError(t, err)
	defer file.Close()

	decoder := json.NewDecoder(file)
	loggedEvents := map[types.JobID]bool{}
	for i := 0; i < totalEvents; i++ {
		var event Event
		assert.NoError(t, decoder.Decode(&event))
		loggedEvents[event.JobID] = true
	}

	assert.Equal(t, totalEvents, len(loggedEvents))
}

// TestConcurrentReplay 測試並發重放（不應該並發）
func TestConcurrentReplay(t *testing.T) {
	tempFile := "test_wal_concurrent_replay.log"
	defer os.Remove(tempFile)

	wal, err := NewWAL(tempFile, true)
	assert.NoError(t, err)

	// Append events
	events := []Event{
		{Type: "ENQUEUE", JobID: types.JobID("job_1"), Timestamp: time.Now().UnixMilli()},
		{Type: "DISPATCH", JobID: types.JobID("job_2"), Timestamp: time.Now().UnixMilli()},
	}
	for _, e := range events {
		err = wal.Append(e.Type, types.Job{ID: e.JobID}, false)
		assert.NoError(t, err)
	}

	// Close WAL to flush buffered events
	err = wal.Close()
	assert.NoError(t, err)

	// Attempt concurrent replay
	wal, err = NewWAL(tempFile, true)
	assert.NoError(t, err)

	var wg sync.WaitGroup
	wg.Add(2)

	var mu sync.Mutex
	allReplayedEvents := []Event{}

	errorCh := make(chan error, 2)
	go func() {
		defer wg.Done()
		localEvents := []Event{}
		handler := func(e Event) error {
			localEvents = append(localEvents, e)
			return nil
		}
		err := wal.Replay(handler)
		if err == nil {
			mu.Lock()
			allReplayedEvents = append(allReplayedEvents, localEvents...)
			mu.Unlock()
		}
		errorCh <- err
	}()
	go func() {
		defer wg.Done()
		localEvents := []Event{}
		handler := func(e Event) error {
			localEvents = append(localEvents, e)
			return nil
		}
		err := wal.Replay(handler)
		if err == nil {
			mu.Lock()
			allReplayedEvents = append(allReplayedEvents, localEvents...)
			mu.Unlock()
		}
		errorCh <- err
	}()

	wg.Wait()
	close(errorCh)

	// Both replays should succeed due to mutex protection
	// But they execute sequentially, so we should have all events replayed twice
	successCount := 0
	for err := range errorCh {
		if err == nil {
			successCount++
		}
	}

	// Both should succeed (execute sequentially due to lock)
	assert.Equal(t, 2, successCount)
	// Events should be replayed twice (2 * len(events))
	assert.Equal(t, 2*len(events), len(allReplayedEvents))
}

// ============================================================================
// 整合測試
// ============================================================================

// TestWALLifecycle 測試完整生命週期
func TestWALLifecycle(t *testing.T) {
	tempFile := "test_wal_lifecycle.log"
	defer os.Remove(tempFile)

	wal, err := NewWAL(tempFile, true)
	assert.NoError(t, err)

	// Write 100 events
	for i := 1; i <= 100; i++ {
		event := Event{
			Type:      "ENQUEUE",
			JobID:     types.JobID(fmt.Sprintf("job_%d", i)),
			Timestamp: time.Now().UnixMilli(),
		}
		err := wal.Append(event.Type, types.Job{ID: event.JobID}, true)
		assert.NoError(t, err)
	}

	// Rotate WAL
	err = wal.Rotate()
	assert.NoError(t, err)

	// Write 50 more events
	for i := 101; i <= 150; i++ {
		event := Event{
			Type:      "ENQUEUE",
			JobID:     types.JobID(fmt.Sprintf("job_%d", i)),
			Timestamp: time.Now().UnixMilli(),
		}
		err := wal.Append(event.Type, types.Job{ID: event.JobID}, true)
		assert.NoError(t, err)
	}

	// Close WAL
	err = wal.Close()
	assert.NoError(t, err)

	// Reopen WAL and replay
	replayedEvents := []Event{}
	handler := func(e Event) error {
		replayedEvents = append(replayedEvents, e)
		return nil
	}

	wal, err = NewWAL(tempFile, true)
	assert.NoError(t, err)
	err = wal.Replay(handler)
	assert.NoError(t, err)

	// Validate replayed events (should only contain the last 50 events)
	assert.Equal(t, 50, len(replayedEvents))
	for i, event := range replayedEvents {
		expectedSeq := uint64(1 + i) // Seq resets to 1 after rotation
		assert.Equal(t, expectedSeq, event.Seq)
		assert.Equal(t, types.JobID(fmt.Sprintf("job_%d", 101+i)), event.JobID)
	}
}

// TestSnapshotIntegration 測試與 Snapshot 的整合
func TestSnapshotIntegration(t *testing.T) {
	tempFile := "test_wal_snapshot_integration.log"
	defer os.Remove(tempFile)

	wal, err := NewWAL(tempFile, true)
	assert.NoError(t, err)

	// Write events 1-100
	for i := 1; i <= 100; i++ {
		event := Event{
			Type:      "ENQUEUE",
			JobID:     types.JobID(fmt.Sprintf("job_%d", i)),
			Timestamp: time.Now().UnixMilli(),
		}
		err := wal.Append(event.Type, types.Job{ID: event.JobID}, true)
		assert.NoError(t, err)
	}

	// Create a snapshot (mock last_seq=100)
	snapshot := SnapshotData{
		LastSeq: 100,
	}
	_ = snapshot // Simulate saving the snapshot

	// Rotate WAL
	err = wal.Rotate()
	assert.NoError(t, err)

	// Write events 101-150
	for i := 101; i <= 150; i++ {
		event := Event{
			Type:      "ENQUEUE",
			JobID:     types.JobID(fmt.Sprintf("job_%d", i)),
			Timestamp: time.Now().UnixMilli(),
		}
		err := wal.Append(event.Type, types.Job{ID: event.JobID}, true)
		assert.NoError(t, err)
	}

	// Simulate crash and recovery
	err = wal.Close()
	assert.NoError(t, err)

	replayedEvents := []Event{}
	handler := func(e Event) error {
		replayedEvents = append(replayedEvents, e)
		return nil
	}

	wal, err = NewWAL(tempFile, true)
	assert.NoError(t, err)
	err = wal.Replay(handler)
	assert.NoError(t, err)

	// Validate final state - after rotation, only the 50 new events remain in active WAL
	// The first 100 events are in the rotated backup file
	assert.Equal(t, 50, len(replayedEvents))
	for i, event := range replayedEvents {
		expectedSeq := uint64(1 + i) // Seq resets after rotation
		assert.Equal(t, expectedSeq, event.Seq)
		assert.Equal(t, types.JobID(fmt.Sprintf("job_%d", 101+i)), event.JobID)
	}
}

// ============================================================================
// 效能測試（Benchmark）
// ============================================================================

// BenchmarkAppend 測試寫入效能
func BenchmarkAppend(b *testing.B) {
	tempFile := "benchmark_wal_append.log"
	defer os.Remove(tempFile)

	wal, err := NewWAL(tempFile, true)
	if err != nil {
		b.Fatalf("Failed to create WAL: %v", err)
	}
	defer wal.Close()

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		event := Event{
			Type:      "ENQUEUE",
			JobID:     types.JobID(fmt.Sprintf("job_%d", i)),
			Timestamp: time.Now().UnixMilli(),
		}
		err := wal.Append(event.Type, types.Job{ID: event.JobID}, false)
		if err != nil {
			b.Fatalf("Failed to append event: %v", err)
		}
	}
}

// BenchmarkReplay 測試重放效能
func BenchmarkReplay(b *testing.B) {
	tempFile := "benchmark_wal_replay.log"
	defer os.Remove(tempFile)

	wal, err := NewWAL(tempFile, true)
	if err != nil {
		b.Fatalf("Failed to create WAL: %v", err)
	}
	defer wal.Close()

	// Prepare WAL with 10,000 events
	numEvents := 10000
	for i := 0; i < numEvents; i++ {
		event := Event{
			Type:      "ENQUEUE",
			JobID:     types.JobID(fmt.Sprintf("job_%d", i)),
			Timestamp: time.Now().UnixMilli(),
		}
		err := wal.Append(event.Type, types.Job{ID: event.JobID}, false)
		if err != nil {
			b.Fatalf("Failed to append event: %v", err)
		}
	}

	// Close WAL to flush all events
	err = wal.Close()
	if err != nil {
		b.Fatalf("Failed to close WAL: %v", err)
	}

	// Benchmark replay
	handler := func(e Event) error {
		return nil
	}

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		wal, err := NewWAL(tempFile, true)
		if err != nil {
			b.Fatalf("Failed to reopen WAL: %v", err)
		}
		err = wal.Replay(handler)
		if err != nil {
			b.Fatalf("Failed to replay WAL: %v", err)
		}
		wal.Close()
	}
}

// BenchmarkBatchWriter 測試批次寫入效能
func BenchmarkBatchWriter(b *testing.B) {
	tempFile := "benchmark_wal_batch_writer.log"
	defer os.Remove(tempFile)

	wal, err := NewWAL(tempFile, true)
	if err != nil {
		b.Fatalf("Failed to create WAL: %v", err)
	}
	defer wal.Close()

	batchSizes := []int{10, 100, 1000}

	for _, batchSize := range batchSizes {
		b.Run(fmt.Sprintf("batch_size_%d", batchSize), func(b *testing.B) {
			b.ResetTimer()
			for i := 0; i < b.N; i++ {
				for j := 0; j < batchSize; j++ {
					event := Event{
						Type:      "ENQUEUE",
						JobID:     types.JobID(fmt.Sprintf("job_%d_%d", i, j)),
						Timestamp: time.Now().UnixMilli(),
					}
					err := wal.Append(event.Type, types.Job{ID: event.JobID}, false)
					if err != nil {
						b.Fatalf("Failed to append event: %v", err)
					}
				}
			}
		})
	}
}

// ============================================================================
// 輔助函式
// ============================================================================

// helper: 建立臨時 WAL 檔案
func createTempWAL(t *testing.T) (*WAL, string) {
	tempDir := t.TempDir()
	tempFile := fmt.Sprintf("%s/test_wal.log", tempDir)

	wal, err := NewWAL(tempFile, true)
	if err != nil {
		t.Fatalf("Failed to create WAL: %v", err)
	}

	return wal, tempFile
}

// helper: 驗證事件內容
func verifyEvent(t *testing.T, event Event, expectedType EventType, expectedJobID types.JobID) {
	if event.Type != expectedType {
		t.Errorf("Expected Type %v, got %v", expectedType, event.Type)
	}
	if event.JobID != expectedJobID {
		t.Errorf("Expected JobID %v, got %v", expectedJobID, event.JobID)
	}
	if event.Checksum == 0 {
		t.Errorf("Checksum should not be zero")
	}
}

// helper: 建立 mock handler
func mockHandler(events *[]Event) EventHandler {
	return func(e Event) error {
		*events = append(*events, e)
		return nil
	}
}

// MockFile simulates a file for testing purposes
type MockFile struct {
	WriteFunc func(p []byte) (n int, err error)
	SyncFunc  func() error
}

func (m *MockFile) Write(p []byte) (n int, err error) {
	if m.WriteFunc != nil {
		return m.WriteFunc(p)
	}
	return len(p), nil
}

func (m *MockFile) Sync() error {
	if m.SyncFunc != nil {
		return m.SyncFunc()
	}
	return nil
}

func (m *MockFile) Close() error {
	return nil
}
